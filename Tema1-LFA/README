*******************************************************************************

			CIOTEC MARIAN-STEFAN 333CA
				TEMA 1 LFA
				
*******************************************************************************

			     LIMBAJE REGULATE
			     
*******************************************************************************

*******************************************************************************
CONTINUT ARHIVA

	FISIERE SURSA
		- reg.y
		- reg.l 
		- utils.h
		- nfa.h
	ALTE FISIERE
		- README
		- Makefile
		

DETALII IMPLEMETARE

	1) DETALII PARSARE
	  1.1) PARASARE ER
	  1.2) PARSARE DFA
	  1.3) PARSARE NFA
	  
	2)DETALII CONVERSII
	  2.1) ER
	    2.1.1) ER -> ER
	    2.1.2) ER -> DFA
	    2.1.3) ER -> NFA
	  2.2) DFA
	    2.2.1) DFA -> ER
	    2.2.2) DFA -> DFA
	    2.2.3) DFA -> NFA
	  2.3) NFA
	    2.3.1) NFA -> ER
	    2.3.2) NFA -> DFA
	    2.3.3) NFA -> NFA
	    
*******************************************************************************

*******************************************************************************
1) DETALII PARASARE
   PENTRU PARSAREA INTRARII AM FOLOSIT FLEX SI BISON. DIN FLEX INTORC TOKENII
   PENTRU BISON, CARE REUNESTE TOKENII IN EXPRESII, PRIN INTERMEDIUL 
   REGULILOR DEFINITE.
   
   1.1) PARSAREA ER
   	AM URMARIT CA PRIN IN UMRA PARSARII UNEI ER SA AM FORMAT UN ARBORE DE
   	PARSARE, ASTFEL SIMPLIFICANDU-SE CONVERSIA DIN ER IN NFA. PENTRU ASTA,
   	AM DEFINIT IN BISON O GRAMATICA NEAMBIGUA PENTRU PARSAREA UNEI ER.
   	IN URMA PARASARII, RADACINA ARBORELUI DE VA AFLA IN VARIABILA Node* root.
   	ALFABETUL ESTE SI EL PARSAT PRIN DEFINIREA UNOR REGULI RECURSIVE;
   	
   1.2) PARSAREA DFA
   	PARSAREA DFA SE FACE TOT IN BISON PRIN DEFINIREA UNOR REGULI RECURSIVE;
   	
   1.3) PARSAREA NFA
   	ESTE FOARTE ASEMANATOAREA CU PARSAREA DFA, SINGURA REGULA CARE DIFERA
   	FIIND CEA CARE PARSEAZA TRANZITIILE(IN REPREZENTAREA DFA AVAND O FORMA
   	DIFERITA FATA DE REPREZENTAREA NFA).
   	
2) DETALII CONVERSII
	2.1) ER
	 2.1.1) ER -> ER
	 	PENTRU REALIZAREA ACESTEI CONVERSII AM FACUT URMATOAREA SERIE DE
	 	TRANSFORMARI: ER->NFA->DFA->ER;
	 2.1.2) ER -> DFA
	 	PENTRU REALIZAREA ACESTEI CONVERSII AM FACUT URMATOAREA SERIE DE
	 	TRANSFORMARI: ER->NFA->DFA;
	 2.1.3) ER -> NFA
	 	PENTRU REALIZAREA ACESTEI CONVERSII AM FACUT URMATOAREA
	 	TRANSFORMARE: ER->NFA;
	 	IMPLEMENTAREA SE GASESTE IN FISIERUL "Nfa.h", IN CLASA NFA, 
	 	FUNCTIA NFA* createNew(Node* node);
	 	CONVERSIA SE BAZEAZA PE ALGORITMUL LUI THOMPSON.
	 	CONVERSIA PORNESTE DE LA ARBORELE DE PARSARE CONSTRUIT ANTERIOR.
	 	PENTRU FIECARE NOD, DACA ESTE FRUNZA(CONTINE UN CARACTER DIN
	 	ALFABET SAU CHIAR SIRUL VID) SE CONSTRUIESTE UN NFA CU STARI
	 	SI O TRANZITIE PE CARACTERUL RESPRECTIV(EXCEPTIE FACE MULTIMEA
	 	VIDA, CAND TRANZITIA NU MAI EXISTA). DACA NU ESTE FRUNZE, SE
	 	PORNESTE RECURSIV SE RAMURILE ARBORELUI PANA LA O FRUNZA.
	 	CONSTRUCTIA ARE LOC PRACTIC PRIN UNIREA UNOR NFA-URI MAI MICI
	 	PANA LA OBTINEA NFA-ULUI FINAL.
	 	http://eli.thegreenplace.net/files/docs/forays/col5.html
	 	
	 2.2) DFA
	  2.2.1) DFA -> ER
	  	 PENTRU REALIZAREA ACESTEI CONVERSII AM FACUT URMATOAREA
	 	 TRANSFORMARE: DFA-> ER;
	 	 IMPLEMENTAREA ACESTEI TRANSFORMARI SE GASESTE IN FISERUL "Nfa.h",
	 	 IN FUNCTIA vector<char> transform_DFA_to_REGEX(DFA* dfa).
	 	 AM FOLOSIT CA SI MODEL Brzozowski algebraic method, CARE 
	 	 PRESUPUNE EXPRIMAREA AUTOMATULUI CA UN SISTEM DE ECUATII DE
	 	 LIMBAJE REGULATE.
	 	 http://cs.stackexchange.com/questions/2016/
	 	 how-to-convert-finite-automata-to-regular-expressions
	 2.2.2) DFA -> DFA
	 	 PENTRU REALIZAREA ACESTEI CONVERII, DOAR AM TRANSFORMAT
	 	 DFA-UL PRIMIT CA INPUT INTR-UN FORMAT PROPRIU SI APOI 
	 	 L-AM AFISAT(FUNCTIA DFA* create_DFA(vector<char*> states, 
	 	 vector<char> alphabet, vector<char*> from, 
	 	 vector<vector<char> > input, vector<char*> to, char* start, 
	 	 vector<char*>final). ESTE AFISAT ACELASI DFA, NUMAI NUMELE
	 	 STARILOR SUNT SCHIMBATE INTR-UN FORMAT DE GENUL "S" URMAT
	 	 DE O CIFRA.
	 2.2.3) DFA -> NFA
	 	 PENTRU ORICE DFA, EXISTA SI O REPREZENTARE IN NFA ECHIVALENTA,
	 	 ASA CA DOAR AM TRANSFORMAT TRANZITIITLE DFA-ULUI IN FORMATUL
	 	 TRANZITIILOR CORESPUNZATOARE NFA-ULUI;
	 	 FUNCTIA NFA* transform_DFA_to_NFA(DFA* dfa) DIN "nfa.h".
	 	 
	2.3) NFA
	  2.3.1) NFA -> ER
		 PENTRU REALIZAREA ACESTEI CONVERSII AM FACUT URMATOAREA SERIE DE
	 	 TRANSFORMARI: NFA -> DFA -> ER.
	  2.3.2) NFA -> DFA
	  	 PNETRU REALIZAREA ACESTEI CONVERSII AM DEFINIT MAI MULTE FUNCTII
	  	 AUXILIARE: vector<int> e_reachable(NFA* nfa, vector<int> from) SI
	  	 vector<int> input_reachable(NFA* nfa, vector<int> from, char in);
	  	 O STARE DIN DFA ESTE REPRZENTATA PRINTR-UN IDENTIFICATOR SI PRINTR-UN
	  	 VECTOR DE STARI DIN NFA IN CARE SE POATE AJUNGE PRIN TRANZITII PE
	  	 SIRUL VID. DECI FIECAREI STARI DIN DFA II CORESPUND UN SET DE STARI
	  	 DIN NFA IN CARE SE POATE AFLA AUTOMATUL. ASTA DIN CAUZA FAPTULUI CA
	  	 UN NFA SE POATE AFLA LA UN MOMENT DAT IN MAI MULTE STARI.
	  	 DACA TRANZITIILE DIN NFA ERAU RETINUTE PRINTR-O MATRICE, TRANZITIILE
	  	 DIN DFA SUNT REPREZENTATE PRINTR-UN VECTOR DE Transition(CARE RETINE
	  	 STAREA DE UNDE PORNESTE TRANZITIA, CARACTERUL PE CARE SE FACE TRANZITIA
	  	 SI STAREA UNDE SE AJUNGE IN URMA TRANZITIEI).
	  	 IMPLEMENTAREA ALGORITMULUI SE GASESTE IN FUNCTIA 
	  	 DFA* transform_NFA_to_DFA(NFA* nfa) DIN "nfa.h"
	  	 http://eli.thegreenplace.net/files/docs/forays/col6.html
*****************************************************************************************
	  	 
   	
   
   	
